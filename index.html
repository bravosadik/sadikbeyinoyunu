<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Flappy Gofret (Kolay)</title>
  <style>
    :root{--stroke:#ffffff18;--text:#e9eeff;--muted:#b7c1ffcc;--accent:#ffd24d;--shadow:0 18px 60px rgba(0,0,0,.45)}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;overflow:hidden;background:#070a13;color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    canvas{position:fixed;inset:0;width:100%;height:100%;display:block}
    .topbar{position:fixed;left:14px;right:14px;top:14px;display:flex;justify-content:space-between;gap:10px;align-items:center;pointer-events:none}
    .hud{pointer-events:none;display:flex;gap:10px;align-items:center;padding:10px 12px;border-radius:999px;background:rgba(11,18,43,.70);border:1px solid var(--stroke);box-shadow:0 10px 30px rgba(0,0,0,.22);backdrop-filter:blur(8px);font-weight:900}
    .hud strong{color:var(--accent)} .hud span{color:var(--muted);font-weight:800}
    .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;padding:16px;background:radial-gradient(900px 520px at 50% 35%, rgba(255,210,77,.10) 0%, rgba(0,0,0,.35) 55%, rgba(0,0,0,.55) 100%)}
    .hide{display:none!important}
    .panel{width:min(920px,94vw);padding:22px;border-radius:22px;background:linear-gradient(180deg, rgba(14,23,52,.78) 0%, rgba(11,16,36,.78) 100%);border:1px solid var(--stroke);box-shadow:var(--shadow);backdrop-filter:blur(10px)}
    .title{display:flex;align-items:center;gap:12px;font-weight:950;letter-spacing:.7px;font-size:clamp(22px,3.5vw,40px);margin:2px 0 12px}
    .pill{font-size:12px;padding:6px 10px;border-radius:999px;border:1px solid var(--stroke);color:var(--muted);background:rgba(11,18,43,.55)}
    .muted{color:var(--muted);font-size:14px;line-height:1.45}
    .row{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px}
    .btn{appearance:none;border:1px solid var(--stroke);background:linear-gradient(180deg,#ffd24d 0%,#f3a51b 100%);color:#231700;padding:12px 14px;border-radius:16px;cursor:pointer;font-weight:900;box-shadow:0 10px 30px rgba(0,0,0,.25);user-select:none;-webkit-tap-highlight-color:transparent;min-width:220px;display:flex;justify-content:space-between;align-items:center;gap:10px}
    .btn:active{transform:translateY(1px)}
    .btn.secondary{background:linear-gradient(180deg,#162356 0%,#0e1839 100%);color:var(--text)}
    .cards{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:14px;margin-top:14px}
    @media (max-width:720px){.cards{grid-template-columns:1fr}.btn{min-width:100%}}
    .card{display:flex;gap:12px;align-items:center;padding:14px;border-radius:18px;border:1px solid var(--stroke);background:rgba(11,18,43,.55);box-shadow:0 10px 30px rgba(0,0,0,.18);cursor:pointer;user-select:none;-webkit-tap-highlight-color:transparent}
    .card:hover{filter:brightness(1.05);border-color:#ffffff28}
    .thumb{width:76px;height:76px;border-radius:16px;background:#0d1633;border:1px solid var(--stroke);display:flex;align-items:center;justify-content:center;overflow:hidden;flex:0 0 auto}
    .thumb img{width:100%;height:100%;object-fit:contain}
    .card h3{margin:0;font-size:16px} .card p{margin:4px 0 0;font-size:13px;color:var(--muted)}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px;background:#0a0f22;padding:2px 7px;border:1px solid #ffffff1c;border-radius:8px;color:#d7deff}
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="topbar">
    <div class="hud"><strong>SKOR</strong> <span id="score">0</span> <span>•</span> <span>EN İYİ</span> <span id="best">0</span></div>
    <div class="hud" style="opacity:.9"><span>ZIPLA:</span> <span class="kbd">SPACE</span> <span>veya</span> <span class="kbd">TIK/DOKUN</span></div>
  </div>

  <div class="overlay" id="mode">
    <div class="panel">
      <div class="title">Mod Seç <span class="pill">kolay</span></div>
      <div class="muted">Mobil/PC ölçeklenir. Zorluk zaten “kolay” ayarlı.</div>
      <div class="row">
        <button class="btn" id="pcBtn"><span>PC</span><span class="kbd">daha keskin</span></button>
        <button class="btn" id="mobBtn"><span>MOBİL</span><span class="kbd">daha büyük</span></button>
      </div>
      <div class="row">
        <button class="btn secondary" id="autoBtn"><span>Otomatik algıla</span><span class="kbd">deneysel</span></button>
      </div>
    </div>
  </div>

  <div class="overlay hide" id="menu">
    <div class="panel">
      <div class="title">Karakter Seç <span class="pill" id="modePill">—</span></div>
      <div class="muted">Seçince başlar. Her yere tık/dokun veya SPACE.</div>
      <div class="cards" id="cards"></div>
      <div class="row">
        <button class="btn secondary" id="backMode"><span>Mod ekranına dön</span><span>↩</span></button>
      </div>
    </div>
  </div>

  <div class="overlay hide" id="over">
    <div class="panel">
      <div class="title">Bitti <span class="pill">kolaydı ama yine de</span></div>
      <div class="muted">Skor: <b id="fs">0</b> • En iyi: <b id="fb">0</b></div>
      <div class="row">
        <button class="btn" id="retry"><span>Tekrar</span><span>⏎</span></button>
        <button class="btn secondary" id="back"><span>Menü</span><span>≡</span></button>
      </div>
    </div>
  </div>

<script>
(() => {
  const CHARACTERS = [
    { key:"gofret", name:"Karakter 1", url:"https://raw.githubusercontent.com/Arassaklak/images/refs/heads/main/gofret.png", desc:"Klasik gofret." },
    { key:"boss",   name:"Karakter 2", url:"https://raw.githubusercontent.com/Arassaklak/images/refs/heads/main/Gemini_Generated_Image_cpthj6cpthj6cpth-removebg-preview.png", desc:"Güçlü duruş." }
  ];

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  const modeOv = document.getElementById("mode");
  const menu = document.getElementById("menu");
  const over = document.getElementById("over");

  const scoreEl = document.getElementById("score");
  const bestEl  = document.getElementById("best");
  const fsEl    = document.getElementById("fs");
  const fbEl    = document.getElementById("fb");

  const cards = document.getElementById("cards");
  const modePill = document.getElementById("modePill");

  const pcBtn = document.getElementById("pcBtn");
  const mobBtn = document.getElementById("mobBtn");
  const autoBtn = document.getElementById("autoBtn");
  const backMode = document.getElementById("backMode");

  const retry = document.getElementById("retry");
  const back  = document.getElementById("back");

  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const rand=(a,b)=>a+Math.random()*(b-a);

  // KOLAY MOD AYARLARI (asıl fark burada)
  const EASY = {
    gravity: 2100,      // daha az => daha yavaş düşer
    jump: 720,          // daha “yumuşak” zıplama
    speed: 300,         // daha yavaş pipe
    gap: 290,           // daha büyük boşluk
    pipeW: 120,
    spawnEvery: 1.55    // daha seyrek engel
  };

  const MODES = {
    pc:     { label:"PC",    renderScale:0.85, worldScale:1.00 },
    mobile: { label:"MOBİL", renderScale:0.90, worldScale:1.15 }
  };

  function guessMode(){
    const coarse = window.matchMedia && window.matchMedia("(pointer: coarse)").matches;
    const small = Math.min(innerWidth, innerHeight) < 780;
    return (coarse || small) ? "mobile" : "pc";
  }

  const S = {
    modeKey:null, mode:null,
    dpr:1, w:0, h:0, groundH:0,
    running:false, dead:false,
    score:0,
    best: Number(localStorage.getItem("flappy_best") || 0),
    x:0, y:0, vy:0,
    pipes:[], spawnT:0,
    sprite:null, spriteKey:null,
    bg:null, bgCtx:null, cloud:null, clouds:[]
  };

  bestEl.textContent = S.best;

  function makeCloudSprite(){
    const c = document.createElement("canvas");
    c.width = 128; c.height = 128;
    const g = c.getContext("2d");
    const rg = g.createRadialGradient(64,64,0,64,64,64);
    rg.addColorStop(0,"rgba(255,255,255,0.55)");
    rg.addColorStop(1,"rgba(255,255,255,0)");
    g.fillStyle = rg;
    g.beginPath(); g.arc(64,64,64,0,Math.PI*2); g.fill();
    return c;
  }

  function rebuildBackground(){
    S.bg = document.createElement("canvas");
    S.bg.width = S.w; S.bg.height = S.h;
    S.bgCtx = S.bg.getContext("2d", { alpha:false });

    const g = S.bgCtx.createLinearGradient(0,0,0,S.h);
    g.addColorStop(0,"#18265b");
    g.addColorStop(0.55,"#0b1020");
    g.addColorStop(1,"#070a13");
    S.bgCtx.fillStyle = g;
    S.bgCtx.fillRect(0,0,S.w,S.h);

    const gy = S.h - S.groundH;
    const gg = S.bgCtx.createLinearGradient(0,gy,0,S.h);
    gg.addColorStop(0,"#1a1a1a");
    gg.addColorStop(1,"#090909");
    S.bgCtx.fillStyle = gg;
    S.bgCtx.fillRect(0,gy,S.w,S.groundH);

    S.bgCtx.fillStyle = "rgba(255,210,77,.08)";
    S.bgCtx.fillRect(0,gy,S.w, Math.max(2, 4*S.dpr));
  }

  function resize(){
    if(!S.mode) return;
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    S.dpr = dpr;

    const rs = S.mode.renderScale;
    S.w = Math.floor(innerWidth * dpr * rs);
    S.h = Math.floor(innerHeight * dpr * rs);
    canvas.width = S.w;
    canvas.height = S.h;

    S.groundH = Math.floor(S.h * 0.12);

    if(!S.running){
      S.x = S.w * 0.28;
      S.y = S.h * 0.50;
      S.vy = 0;
    }

    if(!S.cloud) S.cloud = makeCloudSprite();
    S.clouds = Array.from({length:5}, ()=>({
      x: Math.random()*S.w,
      y: Math.random()*(S.h*0.55)+20,
      s: 0.9 + Math.random()*1.1,
      a: 0.08 + Math.random()*0.08,
      sp: 18 + Math.random()*35
    }));

    rebuildBackground();
  }
  addEventListener("resize", resize, {passive:true});

  function loadImage(url){
    return new Promise((res,rej)=>{
      const img = new Image();
      img.crossOrigin="anonymous";
      img.onload=()=>res(img);
      img.onerror=()=>rej(new Error("Resim yüklenemedi: "+url));
      img.src=url;
    });
  }
  function makeSprite(img){
    const scale = 0.34;
    const w = Math.max(2, Math.floor(img.naturalWidth*scale));
    const h = Math.max(2, Math.floor(img.naturalHeight*scale));
    const c = document.createElement("canvas");
    c.width=w; c.height=h;
    const g = c.getContext("2d");
    const r=2;
    for(let dy=-r; dy<=r; dy++){
      for(let dx=-r; dx<=r; dx++){
        if(dx===0 && dy===0) continue;
        g.globalAlpha=0.18;
        g.drawImage(img, dx, dy, w, h);
      }
    }
    g.globalAlpha=1;
    g.globalCompositeOperation="source-in";
    g.fillStyle="#000"; g.fillRect(0,0,w,h);
    g.globalCompositeOperation="source-over";
    g.shadowColor="rgba(0,0,0,.25)";
    g.shadowBlur=10; g.shadowOffsetY=6;
    g.drawImage(img,0,0,w,h);
    return c;
  }
  const sprites = new Map();
  async function selectCharacter(key){
    const c = CHARACTERS.find(x=>x.key===key);
    if(!c) return;
    if(!sprites.has(key)){
      const img = await loadImage(c.url);
      sprites.set(key, makeSprite(img));
    }
    S.spriteKey=key;
    S.sprite=sprites.get(key);
  }

  function buildCards(){
    cards.innerHTML="";
    for(const c of CHARACTERS){
      const div=document.createElement("div");
      div.className="card";
      div.innerHTML=`
        <div class="thumb"><img alt="${c.name}" src="${c.url}"></div>
        <div><h3>${c.name}</h3><p>${c.desc}</p></div>
      `;
      div.addEventListener("click", async ()=>{
        await selectCharacter(c.key);
        startGame();
      });
      cards.appendChild(div);
    }
  }
  buildCards();

  function setMode(modeKey){
    S.modeKey=modeKey;
    S.mode=MODES[modeKey];
    modePill.textContent=S.mode.label;
    localStorage.setItem("flappy_mode", modeKey);
    resize();
    modeOv.classList.add("hide");
    menu.classList.remove("hide");
    over.classList.add("hide");
    S.running=false; S.dead=false;
  }

  pcBtn.addEventListener("click", ()=>setMode("pc"));
  mobBtn.addEventListener("click", ()=>setMode("mobile"));
  autoBtn.addEventListener("click", ()=>setMode(guessMode()));
  backMode.addEventListener("click", ()=>{
    menu.classList.add("hide");
    modeOv.classList.remove("hide");
  });

  const savedMode = localStorage.getItem("flappy_mode");
  if(savedMode && MODES[savedMode]) setMode(savedMode);

  function reset(){
    S.running=true; S.dead=false;
    S.score=0; scoreEl.textContent="0";
    S.x=S.w*0.28; S.y=S.h*0.50; S.vy=0;
    S.pipes=[]; S.spawnT=0.35;
  }

  function startGame(){
    if(!S.sprite){
      selectCharacter(CHARACTERS[0].key).then(()=>startGame());
      return;
    }
    menu.classList.add("hide");
    over.classList.add("hide");
    reset();
  }

  function gameOver(){
    S.dead=true; S.running=false;
    if(S.score>S.best){
      S.best=S.score;
      localStorage.setItem("flappy_best", String(S.best));
      bestEl.textContent=S.best;
    }
    fsEl.textContent=S.score;
    fbEl.textContent=S.best;
    over.classList.remove("hide");
  }

  retry.addEventListener("click", ()=>{ over.classList.add("hide"); reset(); });
  back.addEventListener("click", ()=>{ over.classList.add("hide"); menu.classList.remove("hide"); });

  function spawnPipe(){
    const ws = S.mode.worldScale;

    const gap = (EASY.gap * ws) * S.dpr;
    const pipeW = (EASY.pipeW * ws) * S.dpr;

    const marginTop = Math.floor(S.h * 0.12);
    const marginBottom = S.groundH + Math.floor(S.h * 0.08);
    const minTop = marginTop + 40*S.dpr;
    const maxTop = S.h - marginBottom - gap - 40*S.dpr;

    const topH = Math.floor(rand(minTop, maxTop));
    const bottomY = topH + gap;

    S.pipes.push({ x:S.w + pipeW + 20*S.dpr, w:pipeW, topH, bottomY, scored:false });
  }

  function rectsOverlap(ax,ay,aw,ah, bx,by,bw,bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  let time=0;
  function drawBackground(dt){
    ctx.drawImage(S.bg,0,0);
    time += dt;

    ctx.globalCompositeOperation="screen";
    const spr=S.cloud;
    for(const c of S.clouds){
      const x=(c.x - time*c.sp) % (S.w + 260);
      ctx.globalAlpha=c.a;
      const w=140*c.s, h=140*c.s;
      ctx.drawImage(spr, x, c.y, w, h);
    }
    ctx.globalAlpha=1;
    ctx.globalCompositeOperation="source-over";
  }

  function drawPipe(p){
    const gy=S.h - S.groundH;
    ctx.fillStyle="rgba(255,210,77,.92)";
    ctx.strokeStyle="rgba(255,255,255,.14)";
    ctx.lineWidth=Math.max(1, 2*S.dpr);

    ctx.fillRect(p.x,0,p.w,p.topH);
    ctx.strokeRect(p.x,0,p.w,p.topH);

    const botH=gy - p.bottomY;
    ctx.fillRect(p.x,p.bottomY,p.w,botH);
    ctx.strokeRect(p.x,p.bottomY,p.w,botH);

    ctx.fillStyle="rgba(0,0,0,.10)";
    const capH=14*S.dpr;
    ctx.fillRect(p.x-8*S.dpr, p.topH-capH, p.w+16*S.dpr, capH);
    ctx.fillRect(p.x-8*S.dpr, p.bottomY, p.w+16*S.dpr, capH);
  }

  function drawPlayer(){
    const ws=S.mode.worldScale;
    const size=(92*ws)*S.dpr;
    const angle=clamp(S.vy/1100, -0.7, 1.0);

    ctx.save();
    ctx.translate(S.x,S.y);
    ctx.rotate(angle);

    const spr=S.sprite;
    const sc=size/Math.max(spr.width,spr.height);
    const dw=spr.width*sc, dh=spr.height*sc;
    ctx.drawImage(spr, -dw/2, -dh/2, dw, dh);
    ctx.restore();
  }

  function jump(){
    if(S.dead){
      over.classList.add("hide");
      reset();
      return;
    }
    if(!S.running) return;
    S.vy = -(EASY.jump * S.mode.worldScale);
  }

  addEventListener("pointerdown", ()=>{
    if(!modeOv.classList.contains("hide")) return;
    if(!menu.classList.contains("hide")) return;
    jump();
  }, {passive:true});

  addEventListener("keydown", (e)=>{
    if(e.code==="Space"){
      e.preventDefault();
      if(!modeOv.classList.contains("hide")) return;
      if(!menu.classList.contains("hide")){
        selectCharacter(CHARACTERS[0].key).then(()=>startGame());
        return;
      }
      jump();
    }
  });

  let last=performance.now();
  function loop(now){
    const dt=clamp((now-last)/1000, 0, 1/24);
    last=now;

    if(!S.mode){
      ctx.fillStyle="#070a13";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      requestAnimationFrame(loop);
      return;
    }

    drawBackground(dt);

    if(S.running){
      const ws=S.mode.worldScale;

      S.vy += (EASY.gravity*ws)*dt;
      S.y  += S.vy*dt;

      S.spawnT -= dt;
      if(S.spawnT <= 0){
        spawnPipe();
        S.spawnT = EASY.spawnEvery;
      }

      const dx=(EASY.speed*ws)*S.dpr*dt;
      for(const p of S.pipes){
        p.x -= dx;
        if(!p.scored && (p.x + p.w) < S.x){
          p.scored=true;
          S.score++;
          scoreEl.textContent=String(S.score);
        }
      }
      S.pipes = S.pipes.filter(p => p.x + p.w > -80*S.dpr);

      const gy=S.h - S.groundH;
      const r=(30*ws)*S.dpr;
      const px=S.x-r, py=S.y-r, pw=r*2, ph=r*2;

      if(S.y + r >= gy){ S.y=gy-r; gameOver(); }
      if(S.y - r <= 0){ S.y=r; S.vy=0; }

      for(const p of S.pipes){
        const top={x:p.x,y:0,w:p.w,h:p.topH};
        const bot={x:p.x,y:p.bottomY,w:p.w,h:gy-p.bottomY};
        if(rectsOverlap(px,py,pw,ph, top.x,top.y,top.w,top.h) ||
           rectsOverlap(px,py,pw,ph, bot.x,bot.y,bot.w,bot.h)){
          gameOver();
          break;
        }
      }
    }

    for(const p of S.pipes) drawPipe(p);
    if(S.sprite) drawPlayer();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
